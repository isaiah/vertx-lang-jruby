	  attr_reader :delegate\n
	  def initialize(delegate)\n
	@if{concrete && concreteSuperTypes.size() > 0}
	    super(delegate);\n
	@end{}
	    @delegate = delegate\n
	  end\n

	@foreach{method:methods}
    \n
	@if{method.comment != null}
	  #@{method.comment.replaceAll('\n(?!$)', '\n  #')}
	@end{}
	  def @if{method.staticMethod}self.@end{}@{method.name} @foreach{param: method.params}@includeNamed{'paramTemplate';param=param;defaultOptions=defaultOptionsMap[method]}@end{', '}\n
	@if{method.fluent}
	    @includeNamed{'invokeDelegate';method=method};\n
			@if{method.returnType instanceof io.vertx.codegen.TypeInfo$Variable}
	    return (@{method.returnType.name}) self\n
			@else{}
	    return self\n
			@end{}
	@else{method.returnType.name.equals('void')}
	    @includeNamed{'invokeDelegate';method=method};\n
	@else{}
		@if{method.cacheReturn}
		    if (cached_@{cacheDecls.size()} != null) {\n
		      return cached_@{cacheDecls.size()};\n
		    }\n
		@end{}
		@if{method.returnType.kind == CLASS_OBJECT}
			@code{cachedType=method.returnType.simpleName}
		    #This cast is cleary flawed\n
		    ret = (@{method.returnType.simpleName}) InternalHelper.wrapObject(@includeNamed{'invokeDelegate';method=method});\n
		@else{method.returnType.kind == CLASS_JSON_OBJECT}
			@code{cachedType='Map<String, Object>'}
		    ret = @includeNamed{'invokeDelegate';method=method}?.getMap();\n
		@else{method.returnType.kind == CLASS_JSON_ARRAY}
			@code{cachedType='List<Object>'}
		    ret = @includeNamed{'invokeDelegate';method=method}?.getList();\n
		@else{method.returnType.kind == CLASS_LIST}
			@code{cachedType=method.returnType.name}
			@if{method.returnType.args[0].kind == CLASS_JSON_OBJECT}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getMap()});\n
			@else{method.returnType.args[0].kind == CLASS_JSON_ARRAY}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getList()});\n
			@else{method.returnType.args[0].kind == CLASS_API}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> @{method.returnType.args[0].simpleName}.FACTORY.apply(underpants)});\n
		  @else{}
		    ret = @includeNamed{'invokeDelegate';method=method};\n
			@end{}
		@else{method.returnType.kind == CLASS_SET}
			@code{cachedType=method.returnType.name}
			@if{method.returnType.args[0].kind == CLASS_JSON_OBJECT}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getMap()}) as Set;\n
			@else{method.returnType.args[0].kind == CLASS_JSON_ARRAY}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getList()}) as Set;\n
			@else{method.returnType.args[0].kind == CLASS_API}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> @{method.returnType.args[0].simpleName}.FACTORY.apply(underpants)}) as Set;\n
			@else{}
		    ret = @includeNamed{'invokeDelegate';method=method};\n
			@end{}
		@else{method.returnType.kind == CLASS_MAP}
			@code{cachedType=method.returnType.name}
			@if{method.returnType.args[1].kind == CLASS_JSON_OBJECT}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collectEntries({k, v -> [k, v.getMap()]});\n
			@else{method.returnType.args[1].kind == CLASS_JSON_ARRAY}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collectEntries({k, v -> [k, v.getList()]});\n
			@else{method.returnType.args[1].kind == CLASS_API}
		    ret = @includeNamed{'invokeDelegate';method=method}?.collectEntries({k, v -> [k, @{method.returnType.args[0].simpleName}.FACTORY.apply(v)]});\n
			@else{}
		    ret = @includeNamed{'invokeDelegate';method=method};\n
			@end{}
		@else{method.returnType.kind == CLASS_ENUM}
			@code{cachedType=method.returnType.name}
		    ret = @includeNamed{'invokeDelegate';method=method};\n
		@else{method.returnType.kind == CLASS_API}
			@code{cachedType=method.returnType.simpleName}
		    ret= @{method.returnType.raw.simpleName}.FACTORY.apply(@includeNamed{'invokeDelegate';method=method});\n
		@else{}
			@code{cachedType=method.returnType.name}
		    ret = @includeNamed{'invokeDelegate';method=method};\n
		@end{}
		@if{method.cacheReturn}
		    cached_@{cacheDecls.size()} = ret\n
			@code{cacheDecls.add('private' + (method.staticMethod ? ' static' : '') + ' ' + cachedType + ' cached_' + cacheDecls.size())}
		@end{}
		    ret\n
		@end{}
	  end\n
	@end{}

	@foreach{cacheDecl:cacheDecls}
	  @{cacheDecl};\n
	@end{}
