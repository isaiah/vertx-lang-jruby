@comment{"This is where the generation starts"}
@comment{"==================================="}

/*\n
 * Copyright 2014 Red Hat, Inc.\n
 *\n
 * Red Hat licenses this file to you under the Apache License, version 2.0\n
 * (the "License"); you may not use this file except in compliance with the\n
 * License.  You may obtain a copy of the License at:\n
 *\n
 * http://www.apache.org/licenses/LICENSE-2.0\n
 *\n
 * Unless required by applicable law or agreed to in writing, software\n
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n
 * License for the specific language governing permissions and limitations\n
 * under the License.\n
 */\n\n

package @{ifacePackageName.replace("io.vertx.", "io.vertx.jruby.")};\n

@comment{'the current index of the cache'}
@code{cacheDecls=new java.util.ArrayList()}

@code{
    constructor = ifaceSimpleName;
    def boxParam(eventType, paramName) {
        rt = eventType.kind;
        rtn = eventType.simpleName;
        if(isPriv(rt)) {
            if(rtn == "int" || rtn == "Integer" || rtn == "long" || rtn == "Long") {
                "context.runtime.newFixnum(" + paramName + ")";
            }else if (rtn == "float" || rtn == "Float" || rtn == "double" || rtn == "Double") {
                "context.runtime.newFloat(" + paramName + ")";
            }else if (rtn == "boolean" || rtn == "Boolean") {
                "context.runtime.newBoolean(" + paramName + ")";
            }else{
                paramName;
            }
        } else if(rt == CLASS_API) {
            return "new " + rubyCounterPart(rtn) + "(context.runtime, metaClass, " + paramName + ")";
        }else if(rt == CLASS_STRING) {
            "context.runtime.newString(" + paramName + ")";
        } else if (rt == CLASS_MAP) {
            mapType = eventType.args[1];
            "context.runtime.newHash((Map<IRubyObject, IRubyObject>)" + paramName + ".entrySet().stream().collect(java.util.stream.Collectors.toMap(e -> context.runtime.newString(e.getKey()), e -> " + boxParam(mapType, "e.getValue()") + ")))";
        } else if (rt == CLASS_JSON_OBJECT) {
            "org.jruby.runtime.Helpers.invoke(context, \"JSON\", \"parse\", context.runtime.newString(" + paramName + ".toString()))"
        } else if (rtn == "Throwable") {
            return "new org.jruby.NativeException(context.runtime, context.runtime.getNativeException(), " + paramName + ")";
        }else{
            paramName;
        }
    }
    def rubyCounterPart(name) {
        name.replace("io.vertx.", "io.vertx.jruby.").replaceAll("\\.([A-Z])", ".Ruby$1");
    }
    def methodParam(m) {
        methodList = methodsByName.get(m);
        ret = new java.util.LinkedHashSet();
        ret.add("ThreadContext context");
        if (st) {
            ret.add("IRubyObject recv");
        }
        overload = methodList.size() > 1;
        if (overload) {
            ret.add("IRubyObject[] args");
        } else {
            for (p : methodList.get(0).params) {
                if (p.type != CLASS_HANDLER) {
                    ret.add("IRubyObject " + p.name);
                }
            }
        }
        for (m : methodList) {
            if (m.kind == METHOD_HANDLER || m.kind == METHOD_FUTURE) {
                ret.add("Block block");
                return ret;
            }
        }
        ret;
    }
    def methodAnno(name) {
        methodList = methodsByName.get(name);
        overload = methodList.size() > 1;
        ret = new java.util.HashMap();
        maxParamLength = 0;
        minParamLength = 0;
        for(method : methodList) {
            if (maxParamLength < method.params.size()) {
                maxParamLength = method.params.size();
            }
            if (minParamLength > method.params.size()) {
                minParamLength = method.params.size();
            }
        }
        required = minParamLength;
        optional = maxParamLength - required;
        ret["name"] = helper.convertCamelCaseToUnderscores(name);
        if (st) {
            ret["meta"] = true;
        }
        if (overload) {
            if (optional != 0) {
                ret["optional"] = optional;
            }
            if (required != 0) {
                ret["required"] = required;
            }
        }
        ret.entrySet();
    }
    def quote(val) {
        if (val instanceof String) {
            "\"" + val + "\"";
        } else {
            val;
        }
    }
    def isPriv(kind) {
        kind == CLASS_PRIMITIVE || kind == CLASS_BOXED_PRIMITIVE
    }
}

@declare{"jrubyanno"}
    @@JRubyMethod(@foreach{field : f}@{field.key}=@{quote(field.value)}@end{', '})\n
@end{}

@declare{"jrubyParams"}
    @foreach{field : methodParam(m)}@{field}@end{', '}
@end{}

@declare{"unboxParam"}
    @code{
        pt = param.type.kind;
        ptn = param.type.name;
        pn = param.name;
        if (overload) {
            pn = "args[" + i + "]";
        }
    }
    @if{isPriv(pt)}
        @if{ptn == 'int' || ptn == 'Integer'}
            RubyNumeric.num2int(@{pn})
        @else{ptn == 'long' || ptn == 'Long'}
            RubyNumeric.num2long(@{pn})
        @else{ptn == "boolean" || ptn == "Boolean"}
            @{param.name}.isTrue()
        @else{}
            @{param.name}.asJavaString()
        @end{}
    @else{pt == CLASS_STRING}
        @{pn}.asJavaString()
    @else{pt == CLASS_API}
        ((@{rubyCounterPart(ptn)}) @{pn}).getDelegate()
    @else{pt == CLASS_HANDLER}
        @code{eventType = param.type.args[0]}
        new Handler<@{eventType.erased.name}>() {\n
            @@Override\n
            public void handle(@{eventType.erased.name} event) {\n
                @includeNamed{"yield"; eventType=eventType}
            }\n
        }\n
    @else{}
        @{pn}
    @end{}
@end{}

@declare{'unboxParams'}
    @code{i = 0}
    @foreach{param: params}
        @includeNamed{'unboxParam'; p=param; overload=overload; i=i}
        @code{i++}
    @end{", "}
@end{}

@declare{"typeMapping"}
    @code{pt = t.kind; pn = t.name}
    @if{isPriv(t.kind)}
        @if{pn == "int" || pn == "Integer" || pn == "float" || pn == "Float"}
            RubyFixnum
        @else{pn == "boolean" ||  pn == "Boolean"}
            RubyBoolean
        @else{}
            RubyString
        @end{}
    @else{t.kind == CLASS_API}
        @{rubyCounterPart(pn)}
    @else{t.kind == CLASS_STRING}
        RubyString
    @else{t.kind == CLASS_JSON_OBJECT || t.kind == CLASS_MAP}
        RubyHash
    @else{t.kind == CLASS_SET || t.kind == CLASS_LIST}
        RubyArray
    @else{}
        RubyHash
    @end{}
@end{}

@declare{"genMethodCall"}
    @if{!method.fluent && !method.returnType.name.equals("void")}
        ret = 
    @end{}
    @if{st}@{type.raw}@else{}this.delegate@end{}.@{method.name}
@end{}

@declare{"invokeDelegate"}
    @if{methodEntry.getValue().size() == 1}
        @includeNamed{"genMethodCall"}(@includeNamed{"unboxParams"; params=method.params; overload=false});\n
    @else{}
        @foreach{method: methodEntry.getValue()}
            @if{method.params.size() > 0}
                @code{i = 0}
                if (
                @foreach{param : method.params}
                    args[@{i}] instanceof @includeNamed{"typeMapping"; t=method.params[i].type}
                    @code{i++}
                @end{" && "}
                ) {\n
                    @includeNamed{"genMethodCall"}(@includeNamed{'unboxParams'; params=method.params; overload=true});\n
                }\n
            @else{}
                @includeNamed{"genMethodCall"}();\n
            @end{}
        @end{}
    @end{}
@end{}

@declare{'boxRet'}
    @code{rt = method.returnType.kind; rtn = method.returnType.simpleName}
    return @{boxParam(method.returnType, "ret")};\n
@end{}

@declare{"yield"}
    @if{eventType.kind == CLASS_VOID}
        block.yieldSpecific(context);\n
    @else{eventType.kind == CLASS_ASYNC_RESULT}
        if (event.succeeded()) {\n
            block.yieldSpecific(context, @{boxParam(eventType.args[0], "event.result()")});\n
        }\n
    @else{}
        block.yieldSpecific(context, @{boxParam(eventType, "event")});
    @end{}
@end{}

import org.jruby.Ruby;\n
import org.jruby.RubyClass;\n
import org.jruby.RubyModule;\n
import org.jruby.RubyObject;\n
import org.jruby.anno.JRubyClass;\n
import org.jruby.anno.JRubyMethod;\n
import org.jruby.runtime.ObjectAllocator;\n
import org.jruby.runtime.ThreadContext;\n
import org.jruby.runtime.Block;\n
import org.jruby.runtime.builtin.IRubyObject;\n
import org.jruby.RubyNumeric;\n
import org.jruby.RubyString;\n
import org.jruby.RubyHash;\n
import org.jruby.RubyArray;\n
import org.jruby.RubyFixnum;\n
import org.jruby.RubyFloat;\n
\n
import @{ifacePackageName}.@{ifaceSimpleName};\n
@comment{"Generate the imports"}
@foreach{importedType:importedTypes}
    @if{importedType.kind == CLASS_API}
        @if{!ifacePackageName.equals(importedType.packageName)}
import @{rubyCounterPart(importedType.toString())};\n
        @end{}
    @end{}
    @if{!importedType.packageName.equals("java.lang")}
import @{importedType};\n
    @end{}
@end{}

@if{ifaceComment != null}
/**\n
 *@{ifaceComment.replaceAll('\n(?!$)', '\n *')}
 */\n
@end{}
@JRubyClass(name = "@{ifaceSimpleName}")\n
public class Ruby@{helper.getSimpleName(ifaceFQCN)} extends RubyObject {\n
    private @{type.raw} delegate;\n
    @comment{"JRuby hooks"}
    public static void createRuby@{constructor}(final Ruby runtime) {\n
      RubyModule mVertx = runtime.getModule("Vertx");\n
      RubyClass c@{constructor} = mVertx.defineClassUnder("@{constructor}", runtime.getObject(), new ObjectAllocator() {\n
        @Override\n
        public RubyClass allocate(Ruby runtime, RubyClass klazz) {\n
          return new Ruby@{constructor}(runtime, klazz);\n
        }\n
      });\n
      c@{constructor}.defineAnnotatedMethods(Ruby@{constructor}.class);\n
    }\n
    public Ruby@{constructor}(Ruby runtime, RubyClass klazz) {\n
      super(runtime, klazz);\n
    }\n

    @comment{"Internal constructor"}
    protected Ruby@{constructor}(Ruby runtime, RubyClass klazz, @{constructor} delegate) {\n
      super(runtime, klazz);\n
      this.delegate = delegate;\n
    }\n

    @comment{"Generate ruby initializers"}
    @JRubyMethod(rest=true)\n
    public IRubyObject initialize(ThreadContext context, IRubyObject[] args) {\n
      this.delegate = new @{constructor}(args);\n
      return this;\n
    }\n

    public @{constructor} getDelegate() {\n
      return delegate;\n
    }\n

@comment{"Generate methods"}
@foreach{methodEntry:methodsByName.entrySet()}
    @code{method = methodEntry.getValue().get(0); st = method.staticMethod}
    @includeNamed{'jrubyanno'; f=methodAnno(methodEntry.getKey())}
    public @if{st}static @end{}IRubyObject @{method.name}(
@includeNamed{"jrubyParams"; m = methodEntry.getKey()}
) {\n
        @comment{"method invoke"}
        @if{!method.fluent && ! method.returnType.name.equals("void")}
            @{method.returnType.simpleName} ret;\n
            @includeNamed{"invokeDelegate"; methodEntry=methodEntry;overload=false}
        @else{}
            @includeNamed{"invokeDelegate"; methodEntry=methodEntry}
        @end{}
        @comment{"dispatch return value"}
        @if{method.fluent}
            return this;\n
        @else{method.returnType.name.equals("void")}
            return context.runtime.getNil();\n
        @else{}
            @includeNamed{"boxRet"}
        @end{}
    }\n
@end{}
@comment{"End of class definition"}
}\n

