private @{type.raw} delegate;\n
public static void createRuby@{constructor}(final Ruby runtime) {\n
  RubyModule mVertx = runtime.getModule("Vertx");\n
  RubyClass c@{constructor} = mVertx.defineClassUnder("@{constructor}", runtime.getObject(), new ObjectAllocator() {\n
    @Override\n
    public RubyClass allocate(Ruby runtime, RubyClass klazz) {\n
      return new Ruby@{constructor}(runtime, klazz);\n
    }\n
  });\n
  c@{constructor}.defineAnnotatedMethod(Ruby@{constructor}.class);\n
}\n
public Ruby@{constructor}(Ruby runtime, RubyClass klazz) {\n
  super(runtime, klazz);\n
}\n

@comment{"Internal constructor"}
protected Ruby@{constructor}(Ruby runtime, RubyClass klazz, @{constructor} delegate) {\n
  super(runtime, klazz);\n
  this.delegate = delegate;\n
}\n

@comment{"Generate ruby initializers"}
@JRubyMethod(rest=true)\n
public IRubyObject initialize(ThreadContext context, IRubyObject[] args) {\n
  this.delegate = new @{constructor}(args);\n
  return this;\n
}\n

public @{constructor} get@{constructor}() {\n
  return delegate;\n
}\n

@foreach{method:methods}
  @if{method.comment != null}
    /**\n
     *@{method.comment.replaceAll('\n(?!$)', '\n   *')}
     */\n
  @end{}
  @JRubyMethod(@if{method.staticMethod}meta=true@end{})\n
  public @if{method.staticMethod}static @end{}@if{method.typeParams.size() > 0}<@foreach{typeParam:method.typeParams}@{typeParam.name}@end{', '}> @end{}IRubyObject @{method.name}(ThreadContext context, @if{method.staticMethod} IRubyObject recv@end{', '}@foreach{param: method.params}@includeNamed{'paramTemplate';param=param;defaultOptions=defaultOptionsMap[method]}@end{', '}) {\n
    @if{method.fluent}
        @includeNamed{'invokeDelegate';method=method};\n
        @if{method.returnType instanceof io.vertx.codegen.TypeInfo$Variable}
return (@{method.returnType.name}) ret;\n
        @else{}
return this;\n
        @end{}
    @else{method.returnType.name.equals('void')}
        @includeNamed{'invokeDelegate';method=method};\n
  return context.runtime.getNil();\n
    @else{}
        @{method.returnType.simpleName} ret;\n
        @if{method.cacheReturn}
            if (cached_@{cacheDecls.size()} != null) {\n
              return cached_@{cacheDecls.size()};\n
            }\n
        @end{}
        @if{method.returnType.kind == CLASS_OBJECT}
            @code{cachedType=method.returnType.simpleName}
            // This cast is cleary flawed\n
            ret = (@{method.returnType.simpleName}) InternalHelper.wrapObject(@includeNamed{'invokeDelegate';method=method});\n
        @else{method.returnType.kind == CLASS_JSON_OBJECT}
            @code{cachedType='Map<String, Object>'}
            ret = @includeNamed{'invokeDelegate';method=method}?.getMap();\n
        @else{method.returnType.kind == CLASS_JSON_ARRAY}
            @code{cachedType='List<Object>'}
            ret = @includeNamed{'invokeDelegate';method=method}?.getList();\n
        @else{method.returnType.kind == CLASS_LIST}
            @code{cachedType=method.returnType.name}
            @if{method.returnType.args[0].kind == CLASS_JSON_OBJECT}
              ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getMap()});\n
            @else{method.returnType.args[0].kind == CLASS_JSON_ARRAY}
              ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getList()});\n
            @else{method.returnType.args[0].kind == CLASS_API}
              ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> @{method.returnType.args[0].simpleName}.FACTORY.apply(underpants)});\n
            @else{}
              ret = @includeNamed{'invokeDelegate';method=method};\n
            @end{}
        @else{method.returnType.kind == CLASS_SET}
            @code{cachedType=method.returnType.name}
            @if{method.returnType.args[0].kind == CLASS_JSON_OBJECT}
              ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getMap()}) as Set;\n
            @else{method.returnType.args[0].kind == CLASS_JSON_ARRAY}
              ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> underpants.getList()}) as Set;\n
            @else{method.returnType.args[0].kind == CLASS_API}
              ret = @includeNamed{'invokeDelegate';method=method}?.collect({underpants -> @{method.returnType.args[0].simpleName}.FACTORY.apply(underpants)}) as Set;\n
            @else{}
              ret = @includeNamed{'invokeDelegate';method=method};\n
            @end{}
        @else{method.returnType.kind == CLASS_MAP}
            @code{cachedType=method.returnType.name}
            @if{method.returnType.args[1].kind == CLASS_JSON_OBJECT}
              ret = @includeNamed{'invokeDelegate';method=method}?.collectEntries({k, v -> [k, v.getMap()]});\n
            @else{method.returnType.args[1].kind == CLASS_JSON_ARRAY}
              ret = @includeNamed{'invokeDelegate';method=method}?.collectEntries({k, v -> [k, v.getList()]});\n
            @else{method.returnType.args[1].kind == CLASS_API}
              ret = @includeNamed{'invokeDelegate';method=method}?.collectEntries({k, v -> [k, @{method.returnType.args[0].simpleName}.FACTORY.apply(v)]});\n
            @else{}
              ret = @includeNamed{'invokeDelegate';method=method};\n
            @end{}
        @else{method.returnType.kind == CLASS_ENUM}
            @code{cachedType=method.returnType.name}
            ret = @includeNamed{'invokeDelegate';method=method};\n
        @else{method.returnType.kind == CLASS_API}
            @code{cachedType=method.returnType.simpleName}
            ret= @includeNamed{'invokeDelegate';method=method};\n
        @else{}
            @code{cachedType=method.returnType.name}
            ret = @includeNamed{'invokeDelegate';method=method};\n
        @end{}
        @if{method.cacheReturn}
            cached_@{cacheDecls.size()} = ret;\n
            @code{cacheDecls.add('private' + (method.staticMethod ? ' static' : '') + ' ' + cachedType + ' cached_' + cacheDecls.size())}
        @end{}
        @if{method.returnType.kind == CLASS_API}
return new Ruby@{method.returnType.simpleName}(context.runtime, metaClass, ret);\n
        @else{}
return @includeNamed{'returnTypeWrap'; returnType=method.returnType};\n
        @end{}
    @end{}
  }\n
@end{}

@foreach{cacheDecl:cacheDecls}
  @{cacheDecl};\n
@end{}
